{
    "contents" : "setGeneric(name=\"fitBMA\",\n           def=function(y, X, parallel=FALSE, ...)\n           {standardGeneric(\"fitBMA\")}\n)\n#' @export\nsetMethod(f=\"fitBMA\", \n          definition= function(y, X, parallel=FALSE, ...){\n            data <- cbind(y,X) # Combine the inputs y and x as a data frame.\n            # Standardize the data input: By setting center=TRUE, centering is done by subtracting the column means of data from the corresponding columns. By setting scale=TRUE, scaling is done by dividing the centered columns of data by their standard deviations.\n            data <- data.frame(scale(data, center=TRUE, scale=TRUE))\n            p <- ncol(X) # p stores the number of covariates\n            id <- unlist(lapply(1:p, function(z) combn(1:p, z, simplify=F)), recursive=FALSE) # Make all possible combinations of 1 through the length of x's columns, taken one to the length of x's column at a time, and make it into a vector named id.\n            colNam <- names(data)[-1] # colNam stores the names of the covariates.\n            # formula stores the list of all possible combinations of regressions. Note that we are excluding the intercept term by adding \"-1\" to all formulas.\n            formula <- lapply(id, function(f) paste(names(data)[1],\"~\", paste(colNam[f], collapse=\"+\"),\"-1\", sep=\"\")) \n            # The last element of formula will be the null model (i.e., The model including only the intercept) Since we standardized the data input, the regression coefficient of this intercept will be zero.\n            formula[[2^p]] <- paste(names(data)[1],\"~\", \"1\", sep=\"\")\n            # Create an empty matix named beta, with the number of row equal to the number of all possible regressions, and the number of column equal to the number of covariates. Entries in the matrix will be the coefficients of each regressions. If the i-th model doesn't include the coefficient j, the corresponding entry_[i,j] will remain NA. \n            beta <- matrix(NA, nrow=length(formula), ncol=ncol(X)+1) \n            colnames(beta) <- c(\"(Intercept)\", names(data)[-1])\n            # Create an empty vector with the length equal to the number of models, to store R-squared values.\n            R.sq <- rep(NA, length(formula))\n            \n            # For each i-th iteration (iteration goes up to the number of models)\n            for (i in 1:length(formula)){ \n              # Fit a regression using i-th element of formula as the formula, and using data, and store it the object fit.\n              fit = lm(formula(formula[[i]]), data) \n              # The vector coefs contains the values of coefficients of i-th iteration of fit\n              coefs <- coef(fit) \n              # i-th row of beta saves the matching coefficient values from the vector coefs.\n              beta[i, colnames(beta) %in% names(coefs)] <- coefs[names(coefs) %in% colnames(beta)] \n              # The i-th element of the vector rsq stores the R-squared value of i-th iteration.\n              R.sq[i] <- summary(fit)$r.squared\n            } # close for\n            # Store the coefficients values in the matrix coefs.\n            coefs <- beta\n            \n            # (2) Posterior Odds\n            # Set up for the second part\n            n <- nrow(data)\n            \n            # P is a vector of the number of covariates included in each model. \n            P <- aaply(beta, .margins=1, .fun=function(x){\n              length(which(!is.na(x)))\n            }, .parallel=parallel\n            ) # close apply\n            \n            \n            # First, calculate the numerator of posterior odds, denoted as B. I divide up the numerator into two terms, first.term, and second.term. These two will be vectors of length 2^(the number of covariates)\n            #            N <- rep(n, length(formula))\n            g <-3\n            \n            first.term <- (1+g)^((n-P-1)/2)\n            second.term <- (1+g*(1-(R.sq)^2))^((-(n-1))/2)\n            # The numerator of posterior odds, B, is a vector consists of diagonal elements of the outer product of two vectors, first.term and second.terms.\n            B <- diag(first.term %o% second.term)\n            # The denominator of posterior odds, B, is the sum of elements of B, and we can also obtain this by innerproduct of two vectors first.term and second.term\n            sum.B <-first.term %*% second.term\n            # post.odds, a vector of length 2^(the number of covariates) will contain the posterior odds of each model.\n            post.odds <- B/sum.B\n            \n            # (3) Posterior expected value of each coefficient\n            # Replace the NAs in the beta matrix to zero. It does make sense to do so, since the coefficient of a variable not included in the model will be zero.\n            beta[is.na(beta)] <- 0\n            # Calculate expected value of each coefficient given the model. This is calculated by assigning weights to each OLS estimate of coefficients. The number of row of resulting matrix is equal to the number of models, and each column represents covariates. \n            e.beta <- g/(g+1) * beta\n            # By multiplying posterior odds of model k with the expected value of a coefficient j in model k, and taing the sum of these across all model space, we can get the posterior expected value of each coefficient. The vector post.beta of length equal to the number of covariates (including intercept) will report these values. j-th element of the vector post.beta represents the posterior expected value of coefficient of the covariate j. \n            post.beta <- post.odds %*% e.beta   \n            \n            #(4) Posterior probability that the coefficient is non-zero. \n            beta[beta!=0] <- 1\n            post.nonzero <- post.odds %*% beta\n            \n            return(new(\"BMA\", coefs=coefs, R.squared=R.sq, post.odds=post.odds, post.beta=post.beta, post.nonzero=post.nonzero))\n          }\n)\n",
    "created" : 1395434141168.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "3528596463",
    "id" : "403A78E6",
    "lastKnownWriteTime" : 6,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}