{
    "contents" : "#' Fitting BMA\n#'\n#' Performs Bayesian Model Average given the linear regressions for every combination of the input covariates with no constant\n#'\n#' @param Y A matrix object; The number of columns is one; The number of rows depends on the data \n#' @param X A matrix object; The number of rows is the same as that of \\code{Y}; The number of columns depends on the data\n#'  \n#' @return An object of class Regressions containing\n#'  \\item{output}{Output includes coefficients and the value of R.squared}\n#' @author Taeyong Park\n#' \n#' @examples\n#' set.seed(0520)\n#' myY <- matrix(sample(1:20, 50, replace=TRUE), 50, 1) \n#' myX <- matrix(c(runif(50), runif(50), rnorm(50), rnorm(50)), 50, 4)\n#' fitBMA(Y=myY, X=myX)\n#' @seealso \\code{\\link{summary}}\n#' @rdname fitBMA\n#' @aliases BMA,ANY-method  \n#' @export\nsetGeneric(name=\"fitBMA\",  # setGeneric sets a generic function\n           def=function(Y, X, ...)\n           {standardGeneric(\"fitBMA\")}\n)\n\n#' @export\nsetMethod(f=\"fitBMA\",  # setMethod specifies the function fitBMA()\n          definition= function(Y, X, g=3, parallel=FALSE, ...){ # g=3 is default for the calculation of the posterior expected value; parallel=FALSE is default for running function in parallel\n            Y <- (Y-mean(Y))/sd(Y) # Standardize dependent variable\n            X <- (X-mean(X))/sd(X) # Standardize covariates\n            data <- data.frame(cbind(Y,X)) # Create a data set\n            p <- ncol(X) # p indicates the number of covariates of the model under consideration\n            id <- unlist(lapply(1:p, function(z) combn(1:p, z, simplify=F)), recursive=FALSE) # This ensures that Z will contain every combination of the covariates.\n            colNam <- names(data)[-1] # Define the name of columns of data\n            formula <- llply(id, function(f) paste(names(data)[1],\"~\", paste(colNam[f], collapse=\"+\"),\"-1\", sep=\"\"), .parallel=parallel) # formula will contain every combination of regressions. It is important to include \"-1\" to ensure that we will drop the intercept when we run regressions using this formula \n            formula[[2^p]] <- paste(names(data)[1],\"~\", \"1\", sep=\"\")   # The last element of formula will be the null model (i.e., The model including only the intercept) Since we standardized the data input, the regression coefficient of this intercept will be zero\n            beta <- matrix(NA, nrow=length(formula), ncol=ncol(X))   # This will contain the coefficients. Since we will not include the intercept, the number of columns of this matrix is the same as the number of colums of the data\n            colnames(beta) <- c(names(data)[-1]) \n            R2 <- eBetaModel <- bayesF <- numeric() # Empty numerics for several statistics \n            for (i in 1:length(formula)){ # This for loop ensures that we run regressions of every possible combination\n              fit = lm(formula(formula[[i]]), data)  \n              coefficients <- coef(fit) \n              beta[i, colnames(beta) %in% names(coefficients)] <- coefficients[names(coefficients) %in% colnames(beta)] # The rows of beta contain coefficients for each iteration\n              R2[i] <- summary(fit)$r.squared # This returns the value of R^2\n            } \n            for (k in 1:length(formula)){\n              p=p  # p indicates the number of covariates of the model under consideration\n              n=nrow(X)  # n indicates the number of rows of input data for explnatory variables\n              bayesF[k] <- (1+g)^((n-p-1)/2)*(1+g*(1-R2[k]))^(-(n-1)/2) # This returns Bayes's factor for the models; This is the posterior model odds for each model\n            }\n            beta[is.na(beta)] <- 0 # This is to make it possible to caluclate eBetaModel below by replacing NA with 0\n            eBetaModel <- (g/(g+1))*beta # This returns E(\\beta_j|M_k) from Slide 3\n            postModel <- bayesF/sum(bayesF) # Posterior probability of the model; The total weight assigned to all models that include each variable; This gives us the posterior probability that the coefficient is non-zero\n            postCoef <- postModel*eBetaModel # Posterior expected value of each coefficient\n            output <- list(coefficients, R2, bayesF, postCoef, postModel)  \n            names(output) <- c(\"coefficients\", \"R.squared\", \"postOdds\", \"postCoef\", \"probSig\")  # postOdds from bayesF; probSig from postModel\n            return((new(\"BMA\", Y=Y, X=X, output=output)))\n          }\n)\n\n\n",
    "created" : 1395428350142.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2760952115",
    "id" : "AB8B4519",
    "lastKnownWriteTime" : 1395438397,
    "path" : "~/GitHub/ProgrammingMidterm/bmaPack/R/fitBMA.R",
    "project_path" : "R/fitBMA.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}